# 시간 복잡도

> 하나의 문제를 푸는데 다양한 알고리즘이 존재한다. 그 중 어떤 알고리즘을 좋을지 분석하기 위해 복잡도 계산을 한다

# 알고리즘 복잡도 계산 항목

- 시간 복잡도 : 알고리즘 실행 속도
- 공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈

## 알고리즘 시간 복잡도의 주요 요소

- 반복문

### **알고리즘 성능 표기법**

- Big O (빅-오) 표기법: O(N)
  - 알고리즘 최악의 실행 시간을 표기
  - **가장 많이/일반적으로 사용함**
  - **아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미이기 때문**
- Ω (오메가) 표기법: Ω(N)
  - 오메가 표기법은 알고리즘 최상의 실행 시간을 표기
- Θ (세타) 표기법: Θ(N)
  - 오메가 표기법은 알고리즘 평균 실행 시간을 표기

> 시간 복잡도 계산은 반복문이 핵심 요소임을 인지하고, 계산 표기는 최상, 평균, 최악 중, 최악의 시간인 Big-O 표기법을 중심으로 익히면 됨

### **대문자 O 표기법[¶](http://localhost:8888/notebooks/%5B%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%20%EC%9D%B4%EB%A1%A0%5D%20%EA%B0%95%EC%9D%98%EC%9E%90%EB%A3%8C/Chapter08-%E1%84%89%E1%85%B5%E1%84%80%E1%85%A1%E1%86%AB%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%83%E1%85%A9-live.ipynb#3.-%EB%8C%80%EB%AC%B8%EC%9E%90-O-%ED%91%9C%EA%B8%B0%EB%B2%95)**

- 빅 오 표기법, Big-O 표기법 이라고도 부름
- O(입력)
  - 입력 n 에 따라 결정되는 시간 복잡도 함수
  - O(1), O(𝑙𝑜𝑔𝑛), O(n), O(nlogn), O(𝑛2), O(2𝑛), O(n!)등으로 표기함
  - 입력 n 의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음
    - O(1) < O(𝑙𝑜𝑔𝑛) < O(n) < O(nlogn) < O(𝑛2) < O(2𝑛) < O(n!)
      - 참고: log n 의 베이스는 2 -
        𝑙𝑜𝑔2𝑛
        log2n
- 단순하게 입력 n에 따라, 몇번 실행이 되는지를 계산하면 됩니다.
  - **표현식에 가장 큰 영향을 미치는 n 의 단위로 표기합니다.**
  - n이 1이든 100이든, 1000이든, 10000이든 실행을
    - 무조건 2회(상수회) 실행한다: O(1)
      ```
      if n> 10:
                print(n)
      ```
    - n에 따라, n번, n + 10 번, 또는 3n + 10 번등 실행한다: O(n)
      ```
           variable= 1
      for numin range(3):
      for indexin range(n):
                    print(index)
      ```
    - n에 따라, 번,  + 1000 번, 100 - 100, 또는 300 + 1번등 실행한다: O()
      ```
           variable= 1
      for iin range(300):
      for numin range(n):
      for indexin range(n):
                        print(index)
      ```
